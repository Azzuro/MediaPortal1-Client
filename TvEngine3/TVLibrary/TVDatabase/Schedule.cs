#region Copyright (C) 2005-2010 Team MediaPortal

// Copyright (C) 2005-2010 Team MediaPortal
// http://www.team-mediaportal.com
// 
// MediaPortal is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
// 
// MediaPortal is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with MediaPortal. If not, see <http://www.gnu.org/licenses/>.

#endregion

using System;
using System.Collections.Generic;
using Gentle.Framework;
using TvLibrary.Interfaces;
using TvLibrary.Log;

namespace TvDatabase
{
  public enum KeepMethodType
  {
    UntilSpaceNeeded,
    UntilWatched,
    TillDate,
    Always
  }

  public enum ScheduleRecordingType
  {
    Once,
    Daily,
    Weekly,
    EveryTimeOnThisChannel,
    EveryTimeOnEveryChannel,
    Weekends,
    WorkingDays
  }

  /// <summary>
  /// Instances of this class represent the properties and methods of a row in the table <b>Schedule</b>.
  /// </summary>
  [TableName("Schedule")]
  public class Schedule : Persistent
  {
    public static DateTime MinSchedule = new DateTime(2000, 1, 1);
    public static readonly int HighestPriority = Int32.MaxValue;
    //public static readonly int LowestPriority;

    #region Members

    private bool isChanged;
    [TableColumn("id_Schedule", NotNull = true), PrimaryKey(AutoGenerated = true)] private int idSchedule;
    [TableColumn("idChannel", NotNull = true), ForeignKey("Channel", "idChannel")] private int idChannel;

    [TableColumn("idParentSchedule", NotNull = true), ForeignKey("Channel", "idParentSchedule")] private int
      idParentSchedule;

    [TableColumn("scheduleType", NotNull = true)] private int scheduleType;
    [TableColumn("programName", NotNull = true)] private string programName;
    [TableColumn("startTime", NotNull = true)] private DateTime startTime;
    [TableColumn("endTime", NotNull = true)] private DateTime endTime;
    [TableColumn("maxAirings", NotNull = true)] private int maxAirings;
    [TableColumn("priority", NotNull = true)] private int priority;
    [TableColumn("directory", NotNull = true)] private string directory;
    [TableColumn("quality", NotNull = true)] private int quality;
    [TableColumn("keepMethod", NotNull = true)] private int keepMethod;
    [TableColumn("keepDate", NotNull = true)] private DateTime keepDate;
    [TableColumn("preRecordInterval", NotNull = true)] private int preRecordInterval;
    [TableColumn("postRecordInterval", NotNull = true)] private int postRecordInterval;
    [TableColumn("canceled", NotNull = true)] private DateTime canceled;
    [TableColumn("recommendedCard", NotNull = true)] private int recommendedCard;
    [TableColumn("series", NotNull = true)] private bool series;

    #endregion

    #region Constructors

    public Schedule(int idChannel, string programName, DateTime startTime, DateTime endTime)
    {
      isChanged = true;
      this.idChannel = idChannel;
      this.idParentSchedule = -1;
      ProgramName = programName;
      Canceled = MinSchedule;
      Directory = "";
      EndTime = endTime;
      KeepDate = MinSchedule;
      KeepMethod = (int)KeepMethodType.UntilSpaceNeeded;
      MaxAirings = Int32.MaxValue; //BAV: changed due to mantis bug 1162 - old value 5;
      PostRecordInterval = 0;
      PreRecordInterval = 0;
      Priority = 0;
      quality = 0;
      BitRateMode = VIDEOENCODER_BITRATE_MODE.NotSet;
      QualityType = QualityType.NotSet;
      ScheduleType = (int)ScheduleRecordingType.Once;
      Series = (scheduleType > 0);
      StartTime = startTime;
      recommendedCard = -1;
    }

    /// <summary> 
    /// Create a new object by specifying all fields (except the auto-generated primary key field). 
    /// </summary> 
    public Schedule(int idChannel, int idParentSchedule, int scheduleType, string programName, DateTime startTime,
                    DateTime endTime,
                    int maxAirings, int priority, string directory, int quality, int keepMethod, DateTime keepDate,
                    int preRecordInterval, int postRecordInterval, DateTime canceled)
    {
      isChanged = true;
      this.idChannel = idChannel;
      this.idParentSchedule = idParentSchedule;
      this.scheduleType = scheduleType;
      this.programName = programName;
      this.startTime = startTime;
      this.endTime = endTime;
      this.maxAirings = maxAirings;
      this.priority = priority;
      this.directory = directory;
      this.quality = quality;
      this.keepMethod = keepMethod;
      this.keepDate = keepDate;
      this.preRecordInterval = preRecordInterval;
      this.postRecordInterval = postRecordInterval;
      this.canceled = canceled;
      this.series = (scheduleType > 0);
      recommendedCard = -1;
    }

    /// <summary> 
    /// Create a new schedule from an existing one (except the auto-generated primary key field). 
    /// </summary> 
    public Schedule(Schedule schedule)
    {
      isChanged = true;
      idChannel = schedule.idChannel;
      idParentSchedule = schedule.idParentSchedule;
      scheduleType = schedule.scheduleType;
      programName = schedule.programName;
      startTime = schedule.startTime;
      endTime = schedule.endTime;
      maxAirings = schedule.maxAirings;
      priority = schedule.priority;
      directory = schedule.directory;
      quality = schedule.quality;
      keepMethod = schedule.keepMethod;
      keepDate = schedule.keepDate;
      preRecordInterval = schedule.preRecordInterval;
      postRecordInterval = schedule.postRecordInterval;
      canceled = schedule.canceled;
      series = schedule.Series;
      recommendedCard = -1;
    }

    /// <summary> 
    /// Create an object from an existing row of data. This will be used by Gentle to 
    /// construct objects from retrieved rows. 
    /// </summary> 
    public Schedule(int idSchedule, int idParentSchedule, int idChannel, int scheduleType, string programName,
                    DateTime startTime,
                    DateTime endTime, int maxAirings, int priority, string directory, int quality, int keepMethod,
                    DateTime keepDate, int preRecordInterval, int postRecordInterval, DateTime canceled)
    {
      this.idSchedule = idSchedule;
      this.idParentSchedule = idParentSchedule;
      this.idChannel = idChannel;
      this.scheduleType = scheduleType;
      this.programName = programName;
      this.startTime = startTime;
      this.endTime = endTime;
      this.maxAirings = maxAirings;
      this.priority = priority;
      this.directory = directory;
      this.quality = quality;
      this.keepMethod = keepMethod;
      this.keepDate = keepDate;
      this.preRecordInterval = preRecordInterval;
      this.postRecordInterval = postRecordInterval;
      this.canceled = canceled;
      this.series = (scheduleType > 0);
      recommendedCard = -1;
    }

    #endregion

    #region Public Properties

    /// <summary>
    /// Indicates whether the entity is changed and requires saving or not.
    /// </summary>
    public bool IsChanged
    {
      get { return isChanged; }
    }

    /// <summary>
    /// Property relating to database column id_Schedule
    /// </summary>
    public int IdSchedule
    {
      get { return idSchedule; }
    }

    /// <summary>
    /// Property to get/set the card id recommended by ConflictsManager plugin
    /// </summary>
    public int RecommendedCard
    {
      get { return recommendedCard; }
      set
      {
        isChanged |= recommendedCard != value;
        recommendedCard = value;
      }
    }

    /// <summary>
    /// Property relating to database column idChannel
    /// </summary>
    public int IdChannel
    {
      get { return idChannel; }
      set
      {
        isChanged |= idChannel != value;
        idChannel = value;
      }
    }

    public int IdParentSchedule
    {
      get { return idParentSchedule; }
      set
      {
        isChanged |= idParentSchedule != value;
        idParentSchedule = value;
      }
    }

    /// <summary>
    /// Property relating to database column scheduleType
    /// </summary>
    public int ScheduleType
    {
      get { return scheduleType; }
      set
      {
        isChanged |= scheduleType != value;
        scheduleType = value;
      }
    }

    /// <summary>
    /// Is schedule a manual one
    /// </summary>
    public bool IsManual
    {
      get
      {
        if (scheduleType != (int)ScheduleRecordingType.Once)
        {
          return false;
        }

        TimeSpan ts = (endTime - startTime);
        return (ts.TotalHours == 24);
      }
    }

    /// <summary>
    /// Property relating to database column programName
    /// </summary>
    public string ProgramName
    {
      get { return programName; }
      set
      {
        isChanged |= programName != value;
        programName = value;
      }
    }

    /// <summary>
    /// Property relating to database column startTime
    /// </summary>
    public DateTime StartTime
    {
      get { return startTime; }
      set
      {
        isChanged |= startTime != value;
        startTime = value;
      }
    }

    /// <summary>
    /// Property relating to database column endTime
    /// </summary>
    public DateTime EndTime
    {
      get { return endTime; }
      set
      {
        isChanged |= endTime != value;
        endTime = value;
      }
    }

    /// <summary>
    /// Property relating to database column maxAirings
    /// </summary>
    public int MaxAirings
    {
      get { return maxAirings; }
      set
      {
        isChanged |= maxAirings != value;
        maxAirings = value;
      }
    }

    /// <summary>
    /// Property relating to database column priority
    /// </summary>
    public int Priority
    {
      get { return priority; }
      set
      {
        isChanged |= priority != value;
        priority = value;
      }
    }

    /// <summary>
    /// Property relating to database column directory
    /// </summary>
    public string Directory
    {
      get { return directory; }
      set
      {
        isChanged |= directory != value;
        directory = value;
      }
    }

    /// <summary>
    /// Property relating to database column quality
    /// </summary>
    public int Quality
    {
      get { return quality; }
      set
      {
        isChanged |= quality != value;
        quality = value;
      }
    }

    /// <summary>
    /// Property relating to database column keepMethod
    /// </summary>
    public int KeepMethod
    {
      get { return keepMethod; }
      set
      {
        isChanged |= keepMethod != value;
        keepMethod = value;
      }
    }

    /// <summary>
    /// Property relating to database column keepDate
    /// </summary>
    public DateTime KeepDate
    {
      get { return keepDate; }
      set
      {
        isChanged |= keepDate != value;
        keepDate = value;
      }
    }

    /// <summary>
    /// Property relating to database column preRecordInterval
    /// </summary>
    public int PreRecordInterval
    {
      get { return preRecordInterval; }
      set
      {
        isChanged |= preRecordInterval != value;
        preRecordInterval = value;
      }
    }

    /// <summary>
    /// Property relating to database column postRecordInterval
    /// </summary>
    public int PostRecordInterval
    {
      get { return postRecordInterval; }
      set
      {
        isChanged |= postRecordInterval != value;
        postRecordInterval = value;
      }
    }

    /// <summary>
    /// Property relating to database column canceled
    /// </summary>
    public DateTime Canceled
    {
      get { return canceled; }
      set
      {
        isChanged |= canceled != value;
        canceled = value;
      }
    }

    #endregion

    #region Storage and Retrieval

    /// <summary>
    /// Static method to retrieve all instances that are stored in the database in one call
    /// </summary>
    public static IList<Schedule> ListAll()
    {
      return Broker.RetrieveList<Schedule>();
    }

    public static Schedule FindNoEPGSchedule(string channelName)
    {
      //channelName
      IList<Channel> channels = Channel.ListAllByName(channelName);

      foreach (Channel ch in channels)
      {
        int idChannel = ch.IdChannel;

        //select * from 'foreigntable'
        SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Schedule));

        // 
        sb.AddConstraint(Operator.Equals, "scheduleType", 0);
        sb.AddConstraint(Operator.Equals, "idChannel", idChannel);
        sb.AddConstraint(Operator.Equals, "idParentSchedule", -1);
        sb.AddConstraint(Operator.Equals, "series", false);
        // passing true indicates that we'd like a list of elements, i.e. that no primary key
        // constraints from the type being retrieved should be added to the statement
        SqlStatement stmt = sb.GetStatement(true);

        // execute the statement/query and create a collection of User instances from the result set
        IList<Schedule> getList = ObjectFactory.GetCollection<Schedule>(stmt.Execute());
        if (getList.Count != 0)
        {
          return getList[0];
        }
      }
      return null;
    }

    public static bool IsScheduleRecording(int id)
    {
      Schedule schedule = Schedule.Retrieve(id);

      if (schedule != null)
      {
        Schedule spawnedSchedule = Schedule.RetrieveSpawnedSchedule(id, schedule.startTime);
        if (spawnedSchedule != null)
        {
          return (Recording.ActiveRecording(spawnedSchedule.idSchedule) != null);
        }
      }
      return (Recording.ActiveRecording(id) != null);
    }

    /// <summary>
    /// Retrieves an entity given it's id.
    /// </summary>
    public static Schedule Retrieve(int id)
    {
      // Return null if id is smaller than seed and/or increment for autokey
      if (id < 1)
      {
        return null;
      }
      Key key = new Key(typeof (Schedule), true, "id_Schedule", id);
      return Broker.TryRetrieveInstance<Schedule>(key);
    }

    /// <summary>
    /// Retrieves an entity given it's id, using Gentle.Framework.Key class.
    /// This allows retrieval based on multi-column keys.
    /// </summary>
    public static Schedule Retrieve(Key key)
    {
      return Broker.TryRetrieveInstance<Schedule>(key);
    }

    public static void SynchProgramStatesForAll()
    {
      Log.Info("schedule.SynchProgramStatesForAll");
      IList<Schedule> allSChedules = Schedule.ListAll();

      if (allSChedules != null && allSChedules.Count > 0)
      {
        foreach (Schedule schedule in allSChedules)
        {
          Schedule.SynchProgramStates(schedule.idSchedule);
        }
      }
    }

    public static void ResetProgramStates(int idSchedule)
    {
      ApplyProgramStates(idSchedule, true);
    }

    private static void SynchProgramStates(int idSchedule)
    {
      ApplyProgramStates(idSchedule, false);
    }

    private static void ApplyProgramStates(int idSchedule, bool clear)
    {
      try
      {
        Schedule schedule = Schedule.Retrieve(idSchedule);
        if (schedule == null)
        {
          return;
        }

        // update the needed program entries (states) based on schedule type-         
        switch (schedule.scheduleType)
        {
          case (int)ScheduleRecordingType.Once:
            Program prgOnce = Program.RetrieveOnce(schedule.programName, schedule.startTime, schedule.endTime,
                                                   schedule.ReferencedChannel().IdChannel);

            //if the program is in the future, then set it as being pending.
            if (prgOnce != null && !schedule.IsSerieIsCanceled(prgOnce.StartTime))
            {
              prgOnce.IsRecordingOncePending = !clear;
              prgOnce.IsRecordingSeriesPending = false;
              prgOnce.Persist();
            }
            break;

          case (int)ScheduleRecordingType.Daily:
            //List<Program> prgsDaily = (List<Program>)Program.RetrieveDaily(schedule.programName, schedule.startTime, DateTime.MaxValue, schedule.ReferencedChannel().IdChannel);
            List<Program> prgsDaily =
              (List<Program>)
              Program.RetrieveDaily(schedule.programName, schedule.startTime, schedule.endTime,
                                    schedule.ReferencedChannel().IdChannel);

            if (prgsDaily != null && prgsDaily.Count > 0)
            {
              foreach (Program prgDaily in prgsDaily)
              {
                if (!schedule.IsSerieIsCanceled(prgDaily.StartTime))
                {
                  //if (prgDaily.StartTime >= schedule.startTime && prgDaily.EndTime <= schedule.endTime) //maybe SQL query could do this faster ?
                  {
                    prgDaily.IsRecordingOncePending = false;
                    prgDaily.IsRecordingSeriesPending = !clear;
                    prgDaily.Persist();
                  }
                }
              }
            }
            break;

          case (int)ScheduleRecordingType.EveryTimeOnEveryChannel:
            List<Program> prgsEveryTimeOnEveryChannel =
              (List<Program>)
              Program.RetrieveEveryTimeOnEveryChannel(schedule.programName, schedule.startTime, DateTime.MaxValue);

            if (prgsEveryTimeOnEveryChannel != null && prgsEveryTimeOnEveryChannel.Count > 0)
            {
              foreach (Program prgEveryTimeOnEveryChannel in prgsEveryTimeOnEveryChannel)
              {
                if (!schedule.IsSerieIsCanceled(prgEveryTimeOnEveryChannel.StartTime))
                {
                  prgEveryTimeOnEveryChannel.IsRecordingOncePending = false;
                  prgEveryTimeOnEveryChannel.IsRecordingSeriesPending = !clear;
                  prgEveryTimeOnEveryChannel.Persist();
                }
              }
            }
            break;

          case (int)ScheduleRecordingType.EveryTimeOnThisChannel:
            List<Program> prgsEveryTimeOnThisChannel =
              (List<Program>)
              Program.RetrieveEveryTimeOnThisChannel(schedule.programName, schedule.startTime, DateTime.MaxValue,
                                                     schedule.ReferencedChannel().IdChannel);

            if (prgsEveryTimeOnThisChannel != null && prgsEveryTimeOnThisChannel.Count > 0)
            {
              foreach (Program prgEveryTimeOnThisChannel in prgsEveryTimeOnThisChannel)
              {
                if (!schedule.IsSerieIsCanceled(prgEveryTimeOnThisChannel.StartTime))
                {
                  prgEveryTimeOnThisChannel.IsRecordingOncePending = false;
                  prgEveryTimeOnThisChannel.IsRecordingSeriesPending = !clear;
                  prgEveryTimeOnThisChannel.Persist();
                }
              }
            }
            break;

          case (int)ScheduleRecordingType.Weekends:
            //List<Program> prgsWeekends = (List<Program>)Program.RetrieveWeekends(schedule.programName, schedule.startTime, DateTime.MaxValue, schedule.ReferencedChannel().IdChannel);
            List<Program> prgsWeekends =
              (List<Program>)
              Program.RetrieveWeekends(schedule.programName, schedule.startTime, schedule.endTime,
                                       schedule.ReferencedChannel().IdChannel);

            if (prgsWeekends != null && prgsWeekends.Count > 0)
            {
              foreach (Program prgWeekends in prgsWeekends)
              {
                if (!schedule.IsSerieIsCanceled(prgWeekends.StartTime))
                {
                  // TODO : following IF statements should be done by WHERE clause in SQL.
                  //do we have a program in the weekend ?
                  //if (prgWeekends.StartTime.DayOfWeek == DayOfWeek.Saturday || prgWeekends.StartTime.DayOfWeek == DayOfWeek.Sunday)
                  {
                    //DateTime start = new DateTime(schedule.startTime.Year, schedule.startTime.Month, prgWeekends.StartTime.Day, schedule.startTime.Hour, schedule.startTime.Minute, schedule.startTime.Second);
                    //DateTime end = new DateTime(schedule.endTime.Year, schedule.endTime.Month, prgWeekends.EndTime.Day, schedule.endTime.Hour, schedule.endTime.Minute, schedule.endTime.Second);

                    //if (prgWeekends.StartTime >= start && prgWeekends.EndTime <= end)
                    {
                      prgWeekends.IsRecordingOncePending = false;
                      prgWeekends.IsRecordingSeriesPending = !clear;
                      prgWeekends.Persist();
                    }
                  }
                }
              }
            }
            break;

          case (int)ScheduleRecordingType.Weekly:
            //List<Program> prgsWeekly = (List<Program>)Program.RetrieveWeekly(schedule.programName, schedule.startTime, DateTime.MaxValue, schedule.ReferencedChannel().IdChannel);
            List<Program> prgsWeekly =
              (List<Program>)
              Program.RetrieveWeekly(schedule.programName, schedule.startTime, schedule.endTime,
                                     schedule.ReferencedChannel().IdChannel);

            if (prgsWeekly != null && prgsWeekly.Count > 0)
            {
              foreach (Program prgWeekly in prgsWeekly)
              {
                if (!schedule.IsSerieIsCanceled(prgWeekly.StartTime))
                {
                  // TODO : following IF statements should be done by WHERE clause in SQL.                    
                  //if (prgWeekly.StartTime.DayOfWeek == schedule.startTime.DayOfWeek)
                  {
                    //DateTime start = new DateTime(schedule.startTime.Year, schedule.startTime.Month, prgWeekly.StartTime.Day, schedule.startTime.Hour, schedule.startTime.Minute, schedule.startTime.Second);
                    //DateTime end = new DateTime(schedule.endTime.Year, schedule.endTime.Month, prgWeekly.EndTime.Day, schedule.endTime.Hour, schedule.endTime.Minute, schedule.endTime.Second);

                    //if (prgWeekly.StartTime >= start && prgWeekly.EndTime <= end)
                    {
                      prgWeekly.IsRecordingOncePending = false;
                      prgWeekly.IsRecordingSeriesPending = !clear;
                      prgWeekly.Persist();
                    }
                  }
                }
              }
            }
            break;

          case (int)ScheduleRecordingType.WorkingDays:
            //List<Program> prgsWorkingDays = (List<Program>)Program.RetrieveWorkingDays(schedule.programName, schedule.startTime, DateTime.MaxValue, schedule.ReferencedChannel().IdChannel);
            List<Program> prgsWorkingDays =
              (List<Program>)
              Program.RetrieveWorkingDays(schedule.programName, schedule.startTime, schedule.endTime,
                                          schedule.ReferencedChannel().IdChannel);

            if (prgsWorkingDays != null && prgsWorkingDays.Count > 0)
            {
              foreach (Program prgWorkingDays in prgsWorkingDays)
              {
                if (!schedule.IsSerieIsCanceled(prgWorkingDays.StartTime))
                {
                  // TODO : following IF statements should be done by WHERE clause in SQL.                    
                  //if (prgWorkingDays.StartTime.DayOfWeek != DayOfWeek.Saturday && prgWorkingDays.StartTime.DayOfWeek != DayOfWeek.Sunday)
                  {
                    //DateTime start = new DateTime(schedule.startTime.Year, schedule.startTime.Month, prgWorkingDays.StartTime.Day, schedule.startTime.Hour, schedule.startTime.Minute, schedule.startTime.Second);
                    //DateTime end = new DateTime(schedule.endTime.Year, schedule.endTime.Month, prgWorkingDays.EndTime.Day, schedule.endTime.Hour, schedule.endTime.Minute, schedule.endTime.Second);

                    //if (prgWorkingDays.StartTime >= start && prgWorkingDays.EndTime <= end)
                    {
                      prgWorkingDays.IsRecordingOncePending = false;
                      prgWorkingDays.IsRecordingSeriesPending = !clear;
                      prgWorkingDays.Persist();
                    }
                  }
                }
              }
            }
            break;
        }
      }
      catch (Exception e)
      {
        Log.Write(e);
      }
    }


    /// <summary>
    /// Persists the entity if it was never persisted or was changed.
    /// </summary>
    public override void Persist()
    {
      if (IsChanged || !IsPersisted)
      {
        try
        {
          base.Persist();

          //WE HAVE TO HANDLE CANCELLED SCHEDULES AND SKIP THOSE - WE DO NOT WANT TO MARK CANCLLED AS recpending.

          SynchProgramStates(this.idSchedule);
        }
        catch (Exception ex)
        {
          Log.Error("Exception in Schedule.Persist() with Message {0}", ex.Message);
          return;
        }
        isChanged = false;
      }
    }

    /// <summary>
    /// Retreives the first found instance of a 'Series' typed schedule given its Channel,Title
    /// </summary>
    /// <param name="idChannel">Channel id to look for</param>
    /// <param name="programName">Title we wanna look for</param>    
    /// <returns>schedule instance or null</returns>
    public static Schedule RetrieveSeries(int idChannel, string programName)
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Schedule));

      // 
      sb.AddConstraint(Operator.NotEquals, "scheduleType", 0);
      sb.AddConstraint(Operator.Equals, "idChannel", idChannel);
      sb.AddConstraint(Operator.Equals, "programName", programName);
      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      IList<Schedule> getList = ObjectFactory.GetCollection<Schedule>(stmt.Execute());
      if (getList.Count != 0)
      {
        return getList[0];
      }
      return null;

      // TODO In the end, a GentleList should be returned instead of an arraylist
      //return new GentleList( typeof(ChannelMap), this );
    }

    /// <summary>
    /// Retreives the first found instance of a 'Series' typed schedule given its Channel,Title,Start and End Times 
    /// </summary>
    /// <param name="idChannel">Channel id to look for</param>
    /// <param name="programName">Title we wanna look for</param>
    /// <param name="startTime">StartTime</param>
    /// <param name="endTime">EndTime</param>
    /// <returns>schedule instance or null</returns>
    public static Schedule RetrieveSeries(int idChannel, string programName, DateTime startTime, DateTime endTime)
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Schedule));

      // 
      sb.AddConstraint(Operator.NotEquals, "scheduleType", 0);
      sb.AddConstraint(Operator.Equals, "idChannel", idChannel);
      sb.AddConstraint(Operator.Equals, "programName", programName);
      sb.AddConstraint(Operator.Equals, "startTime", startTime);
      sb.AddConstraint(Operator.Equals, "endTime", endTime);
      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      IList<Schedule> getList = ObjectFactory.GetCollection<Schedule>(stmt.Execute());
      if (getList.Count != 0)
      {
        return getList[0];
      }
      return null;

      // TODO In the end, a GentleList should be returned instead of an arraylist
      //return new GentleList( typeof(ChannelMap), this );
    }

    /// <summary>
    /// Retreives the first found instance of a 'Series' typed schedule given its Channel,Title,Start and End Times 
    /// </summary>
    /// <param name="idChannel">Channel id to look for</param>    
    /// <param name="startTime">StartTime</param>
    /// <param name="endTime">EndTime</param>
    /// <returns>schedule instance or null</returns>
    public static Schedule RetrieveSeries(int idChannel, DateTime startTime, DateTime endTime)
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Schedule));

      // 
      sb.AddConstraint(Operator.NotEquals, "scheduleType", 0);
      sb.AddConstraint(Operator.Equals, "idChannel", idChannel);
      sb.AddConstraint(Operator.Equals, "startTime", startTime);
      sb.AddConstraint(Operator.Equals, "endTime", endTime);
      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      IList<Schedule> getList = ObjectFactory.GetCollection<Schedule>(stmt.Execute());
      if (getList.Count != 0)
      {
        return getList[0];
      }
      return null;

      // TODO In the end, a GentleList should be returned instead of an arraylist
      //return new GentleList( typeof(ChannelMap), this );
    }

    /// <summary>
    /// Retreives the first found instance of a 'Once' typed schedule given its Channel,Title,Start and End Times 
    /// </summary>
    /// <param name="idChannel">Channel id to look for</param>
    /// <param name="programName">Title we wanna look for</param>
    /// <param name="startTime">StartTime</param>
    /// <param name="endTime">EndTime</param>
    /// <returns>schedule instance or null</returns>
    public static Schedule RetrieveOnce(int idChannel, string programName, DateTime startTime, DateTime endTime)
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Schedule));

      // 
      sb.AddConstraint(Operator.Equals, "scheduleType", 0);
      sb.AddConstraint(Operator.Equals, "idChannel", idChannel);
      sb.AddConstraint(Operator.Equals, "programName", programName);
      sb.AddConstraint(Operator.Equals, "startTime", startTime);
      sb.AddConstraint(Operator.Equals, "endTime", endTime);
      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      IList<Schedule> getList = ObjectFactory.GetCollection<Schedule>(stmt.Execute());
      if (getList.Count != 0)
      {
        return getList[0];
      }
      return null;

      // TODO In the end, a GentleList should be returned instead of an arraylist
      //return new GentleList( typeof(ChannelMap), this );
    }

    #endregion

    #region Relations

    /// <summary>
    /// Get a list of CanceledSchedule referring to the current entity.
    /// </summary>
    public IList<CanceledSchedule> ReferringCanceledSchedule()
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (CanceledSchedule));

      // where foreigntable.foreignkey = ourprimarykey
      sb.AddConstraint(Operator.Equals, "idSchedule", idSchedule);

      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      return ObjectFactory.GetCollection<CanceledSchedule>(stmt.Execute());

      // TODO In the end, a GentleList should be returned instead of an arraylist
      //return new GentleList( typeof(CanceledSchedule), this );
    }

    /// <summary>
    /// Get a list of Conflicts referring to the current entity.
    /// </summary>
    public IList<Conflict> ReferringConflicts()
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Conflict));

      // where foreigntable.foreignkey = ourprimarykey
      sb.AddConstraint(Operator.Equals, "idSchedule", idSchedule);

      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      return ObjectFactory.GetCollection<Conflict>(stmt.Execute());

      // TODO In the end, a GentleList should be returned instead of an arraylist
      //return new GentleList( typeof(CanceledSchedule), this );
    }

    /// <summary>
    /// Get a list of Conflicts referring to the current entity.
    /// </summary>
    public IList<Conflict> ConflictingSchedules()
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Conflict));

      // where foreigntable.foreignkey = ourprimarykey
      sb.AddConstraint(Operator.Equals, "idConflictingSchedule", idSchedule);

      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      return ObjectFactory.GetCollection<Conflict>(stmt.Execute());

      // TODO In the end, a GentleList should be returned instead of an arraylist
      //return new GentleList( typeof(CanceledSchedule), this );
    }


    /// <summary>
    ///
    /// </summary>
    public Channel ReferencedChannel()
    {
      return Channel.Retrieve(IdChannel);
    }

    /// <summary>
    ///
    /// </summary>
    public Schedule ReferencedSchedule()
    {
      return Schedule.Retrieve(idParentSchedule);
    }

    #endregion

    public bool IsSerieIsCanceled(DateTime startTimeParam)
    {
      foreach (CanceledSchedule schedule in ReferringCanceledSchedule())
      {
        if (schedule.CancelDateTime == startTimeParam)
        {
          return true;
        }
      }
      return false;
    }

    public void UnCancelSerie()
    {
      foreach (CanceledSchedule schedule in ReferringCanceledSchedule())
      {
        schedule.Remove();
        //TODO : reset state

        //lets find the child schedule that was cancelled
        //Schedule spawnSchedule = Schedule.RetrieveSpawnedSchedule(schedule.IdSchedule, schedule.CancelDateTime);

        //if (spawnSchedule != null)
        //{

        Program.SetSingleStateSeriesPending(schedule.CancelDateTime,
                                            schedule.ReferencedSchedule().ReferencedChannel().IdChannel,
                                            schedule.ReferencedSchedule().ProgramName);
        //}
      }
      return;
    }

    public void UnCancelSerie(DateTime startTimeParam)
    {
      foreach (CanceledSchedule schedule in ReferringCanceledSchedule())
      {
        if (schedule.CancelDateTime == startTimeParam)
        {
          schedule.Remove();
          Program.SetSingleStateSeriesPending(schedule.CancelDateTime,
                                              schedule.ReferencedSchedule().ReferencedChannel().IdChannel,
                                              schedule.ReferencedSchedule().ProgramName);
          //TODO : reset state
        }
      }
      return;
    }

    /// <summary>
    /// Checks if the recording should record the specified tvprogram
    /// </summary>
    /// <param name="program">TVProgram to check</param>
    /// <returns>true if the specified tvprogram should be recorded</returns>
    /// <returns>filterCanceledRecordings (true/false)
    /// if true then  we'll return false if recording has been canceled for this program</returns>
    /// if false then we'll return true if recording has been not for this program</returns>
    public bool IsRecordingProgram(Program program, bool filterCanceledRecordings)
    {
      if (program == null)
      {
        return false;
      }
      WeekEndTool weekEndTool = Setting.GetWeekEndTool();

      ScheduleRecordingType scheduleRecordingType = (ScheduleRecordingType)ScheduleType;
      switch (scheduleRecordingType)
      {
        case ScheduleRecordingType.Once:
          {
            if (program.StartTime == StartTime && program.EndTime == EndTime && program.IdChannel == IdChannel)
            {
              if (filterCanceledRecordings)
              {
                if (ReferringCanceledSchedule().Count > 0)
                {
                  return false;
                }
              }
              return true;
            }
          }
          break;
        case ScheduleRecordingType.EveryTimeOnEveryChannel:
          if (program.Title == ProgramName)
          {
            if (filterCanceledRecordings && IsSerieIsCanceled(program.StartTime))
            {
              return false;
            }
            return true;
          }
          break;
        case ScheduleRecordingType.EveryTimeOnThisChannel:
          if (program.Title == ProgramName && program.IdChannel == IdChannel)
          {
            if (filterCanceledRecordings && IsSerieIsCanceled(program.StartTime))
            {
              return false;
            }
            return true;
          }
          break;
        case ScheduleRecordingType.Daily:
          if (program.IdChannel == IdChannel)
          {
            int iHourProg = program.StartTime.Hour;
            int iMinProg = program.StartTime.Minute;
            if (iHourProg == StartTime.Hour && iMinProg == StartTime.Minute)
            {
              iHourProg = program.EndTime.Hour;
              iMinProg = program.EndTime.Minute;
              if (iHourProg == EndTime.Hour && iMinProg == EndTime.Minute)
              {
                if (filterCanceledRecordings && IsSerieIsCanceled(program.StartTime))
                {
                  return false;
                }
                return true;
              }
            }
          }
          break;
        case ScheduleRecordingType.WorkingDays:
          if (weekEndTool.IsWorkingDay(program.StartTime.DayOfWeek))
          {
            if (program.IdChannel == IdChannel)
            {
              int iHourProg = program.StartTime.Hour;
              int iMinProg = program.StartTime.Minute;
              if (iHourProg == StartTime.Hour && iMinProg == StartTime.Minute)
              {
                iHourProg = program.EndTime.Hour;
                iMinProg = program.EndTime.Minute;
                if (iHourProg == EndTime.Hour && iMinProg == EndTime.Minute)
                {
                  if (filterCanceledRecordings && IsSerieIsCanceled(program.StartTime))
                  {
                    return false;
                  }
                  return true;
                }
              }
            }
          }
          break;

        case ScheduleRecordingType.Weekends:
          if (weekEndTool.IsWeekend(program.StartTime.DayOfWeek))
          {
            if (program.IdChannel == IdChannel)
            {
              int iHourProg = program.StartTime.Hour;
              int iMinProg = program.StartTime.Minute;
              if (iHourProg == StartTime.Hour && iMinProg == StartTime.Minute)
              {
                iHourProg = program.EndTime.Hour;
                iMinProg = program.EndTime.Minute;
                if (iHourProg == EndTime.Hour && iMinProg == EndTime.Minute)
                {
                  if (filterCanceledRecordings && IsSerieIsCanceled(program.StartTime))
                  {
                    return false;
                  }
                  return true;
                }
              }
            }
          }
          break;

        case ScheduleRecordingType.Weekly:
          if (program.IdChannel == IdChannel)
          {
            int iHourProg = program.StartTime.Hour;
            int iMinProg = program.StartTime.Minute;
            if (iHourProg == StartTime.Hour && iMinProg == StartTime.Minute)
            {
              iHourProg = program.EndTime.Hour;
              iMinProg = program.EndTime.Minute;
              if (iHourProg == EndTime.Hour && iMinProg == EndTime.Minute)
              {
                if ((StartTime.DayOfWeek == program.StartTime.DayOfWeek) && (program.StartTime.Date >= StartTime.Date))
                {
                  if (filterCanceledRecordings && IsSerieIsCanceled(program.StartTime))
                  {
                    return false;
                  }
                  return true;
                }
              }
            }
          }
          break;
      }
      return false;
    }

    //IsRecordingProgram(TVProgram program, bool filterCanceledRecordings)


    public bool DoesUseEpisodeManagement
    {
      get
      {
        if (MaxAirings == Int32.MaxValue)
        {
          return false;
        }
        if (MaxAirings < 1)
        {
          return false;
        }
        return true;
      }
    }

    /// <summary>
    /// Checks whether this recording is finished and can be deleted
    /// 
    /// </summary>
    /// <returns>true:Recording is finished can be deleted
    ///          false:Recording is not done yet, or needs to be done multiple times
    /// </returns>
    public bool IsDone()
    {
      if (ScheduleType != (int)ScheduleRecordingType.Once)
      {
        return false;
      }
      if (DateTime.Now > EndTime)
      {
        return true;
      }
      return false;
    }

    public void Delete()
    {
      int id = this.idSchedule;
      IList<Conflict> list = ReferringConflicts();
      foreach (Conflict conflict in list)
      {
        conflict.Remove();
      }

      list = ConflictingSchedules();
      foreach (Conflict conflict in list)
      {
        conflict.Remove();
      }

      //Schedule parentSeriesSched = RetrieveSeries(this.ReferencedChannel().IdChannel, this.programName, this.startTime, this.endTime);
      //if (parentSeriesSched == null)
      //{
      IList<CanceledSchedule> listCanceledSchedule = ReferringCanceledSchedule();
      foreach (CanceledSchedule schedule in listCanceledSchedule)
      {
        schedule.Remove();
      }
      //}

      // does the schedule still exist ?
      // if yes then remove it, if no leave it.
      Schedule schedExists = Retrieve(idSchedule);
      if (schedExists != null)
      {
        Schedule.ResetProgramStates(id);
        Remove();
      }
    }

    public bool Series
    {
      get { return series; }
      set { series = value; }
    }

    public Schedule Clone()
    {
      Schedule schedule = new Schedule(IdChannel, idParentSchedule, scheduleType, ProgramName, StartTime, EndTime,
                                       MaxAirings, Priority,
                                       Directory, Quality, KeepMethod, KeepDate, PreRecordInterval, PostRecordInterval,
                                       Canceled);

      schedule.series = series;
      schedule.idSchedule = idSchedule;
      schedule.isChanged = false;
      return schedule;
    }

    public bool IsOverlapping(Schedule schedule)
    {
      DateTime Start1 = StartTime.AddMinutes(-preRecordInterval);
      DateTime Start2 = schedule.StartTime.AddMinutes(-schedule.preRecordInterval);
      DateTime End1 = EndTime.AddMinutes(postRecordInterval);
      DateTime End2 = schedule.EndTime.AddMinutes(schedule.postRecordInterval);

      // sch_1        s------------------------e
      // sch_2    ---------s-----------------------------
      // sch_2    s--------------------------------e
      // sch_2  ------------------e
      if ((Start2 >= Start1 && Start2 < End1) ||
          (Start2 <= Start1 && End2 >= End1) ||
          (End2 > Start1 && End2 <= End1))
      {
        return true;
      }
      return false;
    }

    /// <summary>
    /// checks if 2 schedules have a common Transponder
    /// depending on tuningdetails of their respective channels
    /// </summary>
    /// <param name="schedule"></param>
    /// <returns>True if a common transponder exists</returns>
    public bool isSameTransponder(Schedule schedule)
    {
      IList<TuningDetail> tuningList1 = ReferencedChannel().ReferringTuningDetail();
      IList<TuningDetail> tuningList2 = schedule.ReferencedChannel().ReferringTuningDetail();
      foreach (TuningDetail tun1 in tuningList1)
      {
        foreach (TuningDetail tun2 in tuningList2)
        {
          if (tun1.Frequency == tun2.Frequency)
          {
            return true;
          }
        }
      }
      return false;
    }

    public QualityType QualityType
    {
      get { return (QualityType)(quality / 10); }
      set
      {
        int type = ((int)value);
        quality = (type * 10) + (quality % 10);
      }
    }

    public VIDEOENCODER_BITRATE_MODE BitRateMode
    {
      get { return (VIDEOENCODER_BITRATE_MODE)(quality % 10); }
      set
      {
        int mode = ((int)value);
        quality = mode + ((quality / 10) * 10);
      }
    }

    public override string ToString()
    {
      return String.Format("{0} on {1} {2} - {3}  ID={4}", ProgramName, IdChannel, StartTime, EndTime, idSchedule);
    }

    /// <summary>
    /// Retreives the programs with a given title and starting between given Start and End Times 
    /// </summary>
    /// <param name="title">Title we wanna look for</param>
    /// <param name="startTime">StartTime</param>
    /// <param name="endTime">EndTime</param>
    /// <param name="idChannel">The id of the channel</param>
    /// <returns></returns>
    public static IList<Schedule> RetrieveByTitleAndTimesInterval(string title, DateTime startTime, DateTime endTime,
                                                                  int idChannel)
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Schedule));

      // where foreigntable.foreignkey = ourprimarykey
      sb.AddConstraint(Operator.Equals, "programName", title);
      sb.AddConstraint(Operator.GreaterThanOrEquals, "startTime", startTime);
      sb.AddConstraint(Operator.GreaterThanOrEquals, "endTime", endTime);
      sb.AddConstraint(Operator.Equals, "idChannel", idChannel);
      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);
      // execute the statement/query and create a collection of User instances from the result set
      return ObjectFactory.GetCollection<Schedule>(stmt.Execute());
    }

    public static Schedule RetrieveSpawnedSchedule(int parentScheduleId, DateTime startTime)
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Schedule));

      sb.AddConstraint(Operator.Equals, "idParentSchedule", parentScheduleId);
      sb.AddConstraint(Operator.Equals, "startTime", startTime);

      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      IList<Schedule> getList = ObjectFactory.GetCollection<Schedule>(stmt.Execute());
      if (getList.Count != 0)
      {
        return getList[0];
      }
      return null;
    }
  }
}